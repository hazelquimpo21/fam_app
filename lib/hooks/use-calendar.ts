'use client';

/**
 * ============================================================================
 * üìÖ Calendar Integration Hooks
 * ============================================================================
 *
 * React Query hooks for calendar operations:
 * - ICS calendar feeds (create, list, delete)
 * - Google Calendar connections (connect, disconnect, sync)
 * - External events (fetch for display)
 *
 * These hooks provide type-safe, cached access to calendar data with
 * optimistic updates and proper cache invalidation.
 *
 * ============================================================================
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { createClient } from '@/lib/supabase/client';
import { queryKeys } from '@/lib/query-keys';
import { logger } from '@/lib/utils/logger';
import type {
  CalendarFeed,
  CreateCalendarFeedInput,
  UpdateCalendarFeedInput,
  GoogleCalendarConnectionInfo,
  GoogleCalendarSubscription,
  ExternalEvent,
  UpdateCalendarSubscriptionInput,
} from '@/types/calendar';

// ============================================================================
// üì§ ICS CALENDAR FEEDS
// ============================================================================

/**
 * Fetch all calendar feeds for the current family.
 *
 * @returns Query result with array of calendar feeds
 *
 * @example
 * const { data: feeds, isLoading } = useCalendarFeeds()
 * feeds?.forEach(feed => console.log(feed.name, feed.token))
 */
export function useCalendarFeeds() {
  const supabase = createClient();

  return useQuery({
    queryKey: queryKeys.calendar.feeds(),
    queryFn: async (): Promise<CalendarFeed[]> => {
      logger.info('üìÖ Fetching calendar feeds...');

      const { data, error } = await supabase
        .from('calendar_feeds')
        .select('*')
        .order('created_at', { ascending: true });

      if (error) {
        logger.error('Failed to fetch calendar feeds', { error: error.message });
        throw error;
      }

      logger.success(`Loaded ${data?.length || 0} calendar feeds`);
      return data as CalendarFeed[];
    },
    staleTime: 1000 * 60 * 5, // 5 minutes - feeds don't change often
  });
}

/**
 * Create a new calendar feed.
 *
 * The token is auto-generated by the database, and the resulting feed
 * can be subscribed to via the URL: /api/calendar/feed/[token].ics
 *
 * @example
 * const createFeed = useCreateCalendarFeed()
 * createFeed.mutate({
 *   name: 'My Tasks',
 *   include_tasks: true,
 *   include_meals: false,
 * })
 */
export function useCreateCalendarFeed() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (input: CreateCalendarFeedInput): Promise<CalendarFeed> => {
      logger.info('Creating calendar feed...', { name: input.name });

      // Insert the new feed - family_id is auto-filled by RLS
      const { data, error } = await supabase
        .from('calendar_feeds')
        .insert({
          name: input.name,
          member_id: input.member_id ?? null,
          include_tasks: input.include_tasks ?? true,
          include_meals: input.include_meals ?? true,
          include_goals: input.include_goals ?? false,
        })
        .select()
        .single();

      if (error) {
        logger.error('Failed to create calendar feed', { error: error.message });
        throw error;
      }

      logger.success('Calendar feed created!', { id: data.id, token: data.token });
      return data as CalendarFeed;
    },

    onSuccess: () => {
      // Invalidate the feeds list to refresh
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.feeds() });
      toast.success('Calendar feed created!');
    },

    onError: (error) => {
      logger.error('Create calendar feed error', { error });
      toast.error('Failed to create calendar feed');
    },
  });
}

/**
 * Update an existing calendar feed.
 *
 * Use this to change what's included in the feed or rename it.
 * The token remains the same (to preserve existing subscriptions).
 *
 * @example
 * const updateFeed = useUpdateCalendarFeed()
 * updateFeed.mutate({ id: 'abc', include_goals: true })
 */
export function useUpdateCalendarFeed() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (input: UpdateCalendarFeedInput): Promise<CalendarFeed> => {
      const { id, ...updates } = input;
      logger.info('Updating calendar feed...', { id });

      const { data, error } = await supabase
        .from('calendar_feeds')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        logger.error('Failed to update calendar feed', { error: error.message });
        throw error;
      }

      logger.success('Calendar feed updated!');
      return data as CalendarFeed;
    },

    onSuccess: (data) => {
      // Update the cache directly for immediate UI update
      queryClient.setQueryData(queryKeys.calendar.feed(data.id), data);
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.feeds() });
      toast.success('Calendar feed updated!');
    },

    onError: (error) => {
      logger.error('Update calendar feed error', { error });
      toast.error('Failed to update calendar feed');
    },
  });
}

/**
 * Delete a calendar feed.
 *
 * WARNING: This will immediately break any calendar apps subscribed to
 * this feed's URL. They will need to resubscribe to a new feed.
 *
 * @example
 * const deleteFeed = useDeleteCalendarFeed()
 * deleteFeed.mutate('feed-id-123')
 */
export function useDeleteCalendarFeed() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (feedId: string): Promise<string> => {
      logger.info('Deleting calendar feed...', { feedId });

      const { error } = await supabase
        .from('calendar_feeds')
        .delete()
        .eq('id', feedId);

      if (error) {
        logger.error('Failed to delete calendar feed', { error: error.message });
        throw error;
      }

      logger.success('Calendar feed deleted');
      return feedId;
    },

    onSuccess: (feedId) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: queryKeys.calendar.feed(feedId) });
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.feeds() });
      toast('Calendar feed deleted');
    },

    onError: (error) => {
      logger.error('Delete calendar feed error', { error });
      toast.error('Failed to delete calendar feed');
    },
  });
}

/**
 * Regenerate a calendar feed token.
 *
 * This creates a new token for the feed, invalidating the old URL.
 * Use this if a feed URL has been compromised or shared accidentally.
 *
 * @example
 * const regenerate = useRegenerateCalendarFeedToken()
 * regenerate.mutate('feed-id-123')
 */
export function useRegenerateCalendarFeedToken() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (feedId: string): Promise<CalendarFeed> => {
      logger.info('Regenerating calendar feed token...', { feedId });

      // Generate a new random token (48 hex chars)
      const newToken = Array.from(crypto.getRandomValues(new Uint8Array(24)))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');

      const { data, error } = await supabase
        .from('calendar_feeds')
        .update({
          token: newToken,
          access_count: 0, // Reset access count for new token
          last_accessed_at: null,
          updated_at: new Date().toISOString(),
        })
        .eq('id', feedId)
        .select()
        .single();

      if (error) {
        logger.error('Failed to regenerate token', { error: error.message });
        throw error;
      }

      logger.success('Calendar feed token regenerated!');
      return data as CalendarFeed;
    },

    onSuccess: (data) => {
      queryClient.setQueryData(queryKeys.calendar.feed(data.id), data);
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.feeds() });
      toast.success('New calendar link generated!');
    },

    onError: (error) => {
      logger.error('Regenerate token error', { error });
      toast.error('Failed to regenerate calendar link');
    },
  });
}


// ============================================================================
// üîó GOOGLE CALENDAR CONNECTION
// ============================================================================

/**
 * Fetch the current user's Google Calendar connection.
 *
 * Returns null if not connected. Use this to show connection status
 * in the settings UI.
 *
 * @example
 * const { data: connection, isLoading } = useGoogleCalendarConnection()
 * if (connection) {
 *   console.log('Connected as:', connection.google_email)
 * }
 */
export function useGoogleCalendarConnection() {
  const supabase = createClient();

  return useQuery({
    queryKey: queryKeys.calendar.myConnection(),
    queryFn: async (): Promise<GoogleCalendarConnectionInfo | null> => {
      logger.info('Fetching Google Calendar connection...');

      // Get current user's family member ID first
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        logger.warn('No authenticated user');
        return null;
      }

      // Get the member record
      const { data: member, error: memberError } = await supabase
        .from('family_members')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (memberError || !member) {
        logger.info('No family member record found');
        return null;
      }

      // Get the Google connection (without sensitive tokens)
      const { data, error } = await supabase
        .from('google_calendar_connections')
        .select('id, google_email, last_synced_at, sync_error, created_at')
        .eq('member_id', member.id)
        .single();

      if (error) {
        // No connection is not an error - it's just not connected
        if (error.code === 'PGRST116') {
          logger.info('No Google Calendar connection found');
          return null;
        }
        logger.error('Failed to fetch Google connection', { error: error.message });
        throw error;
      }

      logger.success('Google Calendar connection loaded', { email: data.google_email });
      return data as GoogleCalendarConnectionInfo;
    },
    staleTime: 1000 * 60, // 1 minute
  });
}

/**
 * Disconnect Google Calendar.
 *
 * This removes the OAuth connection and deletes all imported events.
 * The user will need to re-authorize to connect again.
 *
 * @example
 * const disconnect = useDisconnectGoogleCalendar()
 * disconnect.mutate()
 */
export function useDisconnectGoogleCalendar() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (): Promise<void> => {
      logger.info('Disconnecting Google Calendar...');

      // Get current user's member ID
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: member } = await supabase
        .from('family_members')
        .select('id')
        .eq('auth_user_id', user.id)
        .single();

      if (!member) throw new Error('No family member record');

      // Delete the connection (cascades to subscriptions and events)
      const { error } = await supabase
        .from('google_calendar_connections')
        .delete()
        .eq('member_id', member.id);

      if (error) {
        logger.error('Failed to disconnect Google Calendar', { error: error.message });
        throw error;
      }

      logger.success('Google Calendar disconnected');
    },

    onSuccess: () => {
      // Clear all calendar-related cache
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.all });
      toast.success('Google Calendar disconnected');
    },

    onError: (error) => {
      logger.error('Disconnect error', { error });
      toast.error('Failed to disconnect Google Calendar');
    },
  });
}


// ============================================================================
// üìã CALENDAR SUBSCRIPTIONS
// ============================================================================

/**
 * Fetch calendar subscriptions for the current user's connection.
 *
 * These are the Google Calendars that have been selected for import.
 *
 * @example
 * const { data: subscriptions } = useCalendarSubscriptions()
 * subscriptions?.filter(s => s.is_active).forEach(...)
 */
export function useCalendarSubscriptions() {
  const supabase = createClient();

  return useQuery({
    queryKey: queryKeys.calendar.subscriptions('current'),
    queryFn: async (): Promise<GoogleCalendarSubscription[]> => {
      logger.info('Fetching calendar subscriptions...');

      // This query joins through the connection to get the current user's subscriptions
      const { data, error } = await supabase
        .from('google_calendar_subscriptions')
        .select(`
          *,
          google_calendar_connections!inner(member_id)
        `)
        .order('calendar_name');

      if (error) {
        logger.error('Failed to fetch subscriptions', { error: error.message });
        throw error;
      }

      logger.success(`Loaded ${data?.length || 0} calendar subscriptions`);
      // Strip the join data and return just the subscriptions
      return (data || []).map(({ google_calendar_connections, ...sub }) => sub) as GoogleCalendarSubscription[];
    },
    staleTime: 1000 * 60, // 1 minute
  });
}

/**
 * Update a calendar subscription (toggle active, change visibility).
 *
 * @example
 * const update = useUpdateCalendarSubscription()
 * update.mutate({ id: 'sub-123', is_active: false })
 */
export function useUpdateCalendarSubscription() {
  const queryClient = useQueryClient();
  const supabase = createClient();

  return useMutation({
    mutationFn: async (input: UpdateCalendarSubscriptionInput): Promise<GoogleCalendarSubscription> => {
      const { id, ...updates } = input;
      logger.info('Updating calendar subscription...', { id });

      const { data, error } = await supabase
        .from('google_calendar_subscriptions')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        logger.error('Failed to update subscription', { error: error.message });
        throw error;
      }

      logger.success('Calendar subscription updated');
      return data as GoogleCalendarSubscription;
    },

    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.subscriptions('current') });
      toast.success('Calendar settings updated');
    },

    onError: (error) => {
      logger.error('Update subscription error', { error });
      toast.error('Failed to update calendar settings');
    },
  });
}


// ============================================================================
// üìÜ EXTERNAL EVENTS
// ============================================================================

/**
 * Fetch external events for today.
 *
 * Use this on the Today page to show upcoming appointments.
 *
 * @example
 * const { data: events } = useTodayExternalEvents()
 * events?.forEach(event => console.log(event.title, event.start_time))
 */
export function useTodayExternalEvents() {
  const supabase = createClient();

  return useQuery({
    queryKey: queryKeys.calendar.todayEvents(),
    queryFn: async (): Promise<ExternalEvent[]> => {
      logger.info('Fetching today\'s external events...');

      // Calculate today's date range in local timezone
      const today = new Date();
      const startOfDay = new Date(today.setHours(0, 0, 0, 0)).toISOString();
      const endOfDay = new Date(today.setHours(23, 59, 59, 999)).toISOString();

      const { data, error } = await supabase
        .from('external_events')
        .select('*')
        .gte('start_time', startOfDay)
        .lte('start_time', endOfDay)
        .order('start_time');

      if (error) {
        logger.error('Failed to fetch today\'s events', { error: error.message });
        throw error;
      }

      logger.success(`Loaded ${data?.length || 0} external events for today`);
      return data as ExternalEvent[];
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}

/**
 * Fetch external events for a date range.
 *
 * Use this for the Calendar view to show appointments alongside Fam events.
 *
 * @param startDate - Start of range (ISO date string)
 * @param endDate - End of range (ISO date string)
 *
 * @example
 * const { data: events } = useExternalEvents('2024-01-01', '2024-01-31')
 */
export function useExternalEvents(startDate: string, endDate: string) {
  const supabase = createClient();

  return useQuery({
    queryKey: queryKeys.calendar.externalEvents(startDate, endDate),
    queryFn: async (): Promise<ExternalEvent[]> => {
      logger.info('Fetching external events...', { startDate, endDate });

      const { data, error } = await supabase
        .from('external_events')
        .select('*')
        .gte('start_time', startDate)
        .lte('start_time', endDate)
        .order('start_time');

      if (error) {
        logger.error('Failed to fetch external events', { error: error.message });
        throw error;
      }

      logger.success(`Loaded ${data?.length || 0} external events`);
      return data as ExternalEvent[];
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
    // Only fetch if we have valid dates
    enabled: !!startDate && !!endDate,
  });
}


// ============================================================================
// üîÑ SYNC OPERATIONS
// ============================================================================

/**
 * Trigger a manual sync of Google Calendar events.
 *
 * This fetches the latest events from Google and updates the local cache.
 * Use this when the user clicks "Sync Now" in settings.
 *
 * @example
 * const sync = useSyncGoogleCalendar()
 * sync.mutate()
 */
export function useSyncGoogleCalendar() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (): Promise<{ synced: number }> => {
      logger.info('Triggering Google Calendar sync...');

      // Call our API endpoint that handles the sync
      const response = await fetch('/api/calendar/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Sync failed');
      }

      const result = await response.json();
      logger.success('Google Calendar synced', { synced: result.synced });
      return result;
    },

    onSuccess: (result) => {
      // Invalidate all external event queries to show new data
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.todayEvents() });
      queryClient.invalidateQueries({ queryKey: queryKeys.calendar.myConnection() });
      toast.success(`Synced ${result.synced} events from Google Calendar`);
    },

    onError: (error) => {
      logger.error('Sync error', { error });
      toast.error('Failed to sync calendar. Try reconnecting your Google account.');
    },
  });
}


// ============================================================================
// üõ†Ô∏è UTILITY HOOKS
// ============================================================================

/**
 * Get the full URL for a calendar feed.
 *
 * @param token - The feed's token
 * @returns The full subscribable URL
 *
 * @example
 * const url = useCalendarFeedUrl('abc123def456')
 * // Returns: https://fam.app/api/calendar/feed/abc123def456.ics
 */
export function useCalendarFeedUrl(token: string): string {
  // In production, use the actual domain. For now, use window.location.origin
  if (typeof window === 'undefined') {
    return `/api/calendar/feed/${token}.ics`;
  }
  return `${window.location.origin}/api/calendar/feed/${token}.ics`;
}

/**
 * Copy a calendar feed URL to clipboard.
 *
 * @example
 * const copyUrl = useCopyCalendarFeedUrl()
 * copyUrl('abc123def456')
 */
export function useCopyCalendarFeedUrl() {
  return async (token: string): Promise<void> => {
    const url = typeof window !== 'undefined'
      ? `${window.location.origin}/api/calendar/feed/${token}.ics`
      : `/api/calendar/feed/${token}.ics`;

    try {
      await navigator.clipboard.writeText(url);
      toast.success('Calendar link copied to clipboard!');
    } catch {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = url;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      toast.success('Calendar link copied!');
    }
  };
}
